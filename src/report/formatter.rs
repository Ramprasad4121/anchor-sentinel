//! # Report Formatters
//!
//! @title Report Format Converters
//! @author Ramprasad
//!
//! Provides formatting functions to convert reports into various output formats
//! including Markdown and SARIF.

use super::{Finding, Report, Severity};

/// Converts a report to Markdown format.
///
/// Generates a well-structured Markdown document suitable for documentation
/// or GitHub issue tracking.
///
/// # Arguments
///
/// * `report` - The report to format
///
/// # Returns
///
/// A Markdown-formatted string.
pub fn to_markdown(report: &Report) -> String {
    let mut md = String::new();

    // Header
    md.push_str("# Anchor-Sentinel Security Report\n\n");

    // Metadata
    md.push_str("## Scan Information\n\n");
    md.push_str("| Property | Value |\n");
    md.push_str("|----------|-------|\n");
    md.push_str(&format!(
        "| **Tool Version** | {} |\n",
        report.metadata.version
    ));
    md.push_str(&format!(
        "| **Scan Timestamp** | {} |\n",
        report.metadata.timestamp
    ));
    md.push_str(&format!(
        "| **Path Scanned** | `{}` |\n",
        report.metadata.scanned_path
    ));
    md.push_str(&format!(
        "| **Files Analyzed** | {} |\n",
        report.metadata.files_analyzed
    ));
    md.push_str("\n");

    // Summary
    md.push_str("## Summary\n\n");
    md.push_str("| Severity | Count |\n");
    md.push_str("|----------|-------|\n");
    md.push_str(&format!("| Critical | {} |\n", report.summary.critical));
    md.push_str(&format!("| High | {} |\n", report.summary.high));
    md.push_str(&format!("| Medium | {} |\n", report.summary.medium));
    md.push_str(&format!("| Low | {} |\n", report.summary.low));
    md.push_str(&format!("| Info | {} |\n", report.summary.info));
    md.push_str(&format!("| **Total** | **{}** |\n", report.summary.total));
    md.push_str("\n");

    // Findings
    if report.findings.is_empty() {
        md.push_str("## No Vulnerabilities Found\n\n");
        md.push_str("The analyzed code passed all security checks.\n");
    } else {
        md.push_str("## Detailed Findings\n\n");

        for severity in [
            Severity::Critical,
            Severity::High,
            Severity::Medium,
            Severity::Low,
            Severity::Info,
        ] {
            let severity_findings: Vec<_> = report
                .findings
                .iter()
                .filter(|f| f.severity == severity)
                .collect();

            if severity_findings.is_empty() {
                continue;
            }

            md.push_str(&format!("### {} Findings\n\n", severity));

            for (i, finding) in severity_findings.iter().enumerate() {
                md.push_str(&format_finding_markdown(finding, i + 1));
            }
        }
    }

    // Footer
    md.push_str("---\n\n");
    md.push_str("*Report generated by Anchor-Sentinel*\n");

    md
}

/// Formats a single finding as Markdown.
fn format_finding_markdown(finding: &Finding, index: usize) -> String {
    let mut md = String::new();

    md.push_str(&format!(
        "#### [{}-{}] {}\n\n",
        finding.detector_id, index, finding.title
    ));

    md.push_str(&format!("{}\n\n", finding.severity.markdown_badge()));

    md.push_str(&format!(
        "**Location:** `{}` (Line {})\n\n",
        finding.file_path, finding.line
    ));

    md.push_str("**Description:**\n\n");
    md.push_str(&finding.description);
    md.push_str("\n\n");

    if let Some(ref snippet) = finding.code_snippet {
        md.push_str("**Vulnerable Code:**\n\n");
        md.push_str("```rust\n");
        md.push_str(snippet);
        md.push_str("\n```\n\n");
    }

    if let Some(ref cwe) = finding.cwe {
        md.push_str(&format!(
            "**Reference:** [{}](https://cwe.mitre.org/data/definitions/{}.html)\n\n",
            cwe,
            cwe.strip_prefix("CWE-").unwrap_or(cwe)
        ));
    }

    md.push_str("**Remediation:**\n\n");
    md.push_str(&finding.remediation);
    md.push_str("\n\n");

    md.push_str("---\n\n");

    md
}

/// Converts a report to SARIF format for CI/CD integration.
///
/// SARIF (Static Analysis Results Interchange Format) is a standard format
/// for static analysis tools that integrates with GitHub, Azure DevOps, etc.
///
/// # Arguments
///
/// * `report` - The report to format
///
/// # Returns
///
/// A JSON string in SARIF 2.1.0 format.
pub fn to_sarif(report: &Report) -> String {
    serde_json::json!({
        "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
        "version": "2.1.0",
        "runs": [{
            "tool": {
                "driver": {
                    "name": "Anchor-Sentinel",
                    "version": report.metadata.version,
                    "informationUri": "https://github.com/Ramprasad4121/anchor-sentinel",
                    "rules": report.findings.iter().map(|f| {
                        serde_json::json!({
                            "id": f.detector_id,
                            "name": f.title,
                            "shortDescription": { "text": f.title },
                            "fullDescription": { "text": f.description },
                            "defaultConfiguration": {
                                "level": match f.severity {
                                    Severity::Critical | Severity::High => "error",
                                    Severity::Medium => "warning",
                                    _ => "note"
                                }
                            }
                        })
                    }).collect::<Vec<_>>()
                }
            },
            "results": report.findings.iter().map(|f| {
                serde_json::json!({
                    "ruleId": f.detector_id,
                    "level": match f.severity {
                        Severity::Critical | Severity::High => "error",
                        Severity::Medium => "warning",
                        _ => "note"
                    },
                    "message": { "text": f.description },
                    "locations": [{
                        "physicalLocation": {
                            "artifactLocation": { "uri": f.file_path },
                            "region": { "startLine": f.line }
                        }
                    }]
                })
            }).collect::<Vec<_>>()
        }]
    })
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_markdown_generation() {
        let findings = vec![Finding {
            id: "test-1".to_string(),
            detector_id: "V001".to_string(),
            title: "Test Finding".to_string(),
            description: "Test description".to_string(),
            severity: Severity::High,
            file_path: "test.rs".to_string(),
            line: 10,
            location: "Test::field".to_string(),
            code_snippet: Some("pub field: AccountInfo".to_string()),
            remediation: "Fix it".to_string(),
            cwe: Some("CWE-862".to_string()),
        }];

        let report = Report::new(findings, PathBuf::from("./test"));
        let md = to_markdown(&report);

        assert!(md.contains("# Anchor-Sentinel Security Report"));
        assert!(md.contains("V001"));
        assert!(md.contains("Test Finding"));
    }
}
